<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AeonAnima Symbol Generator</title>
  <style>
    :root {
      --primary-color: #6a3cb5;
      --primary-light: #8a63d2;
      --primary-dark: #4e2c87;
      --secondary-color: #3498db;
      --background: #121212;
      --card-background: #1e1e1e;
      --text-color: #e0e0e0;
      --light-text: #aaaaaa;
      --accent-color: #9d4edd;
      
      --font-heading: 'Cinzel', serif;
      --font-body: 'Inter', sans-serif;
      
      --spacing-xs: 0.25rem;
      --spacing-sm: 0.5rem;
      --spacing-md: 1rem;
      --spacing-lg: 1.5rem;
      --spacing-xl: 2.5rem;
      
      --radius-sm: 4px;
      --radius-md: 8px;
      --radius-lg: 12px;
      --radius-full: 9999px;
      
      --card-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
      --text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    @keyframes gradientShift {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    @keyframes glow {
      0% { box-shadow: 0 0 10px rgba(157, 78, 221, 0.5); }
      50% { box-shadow: 0 0 20px rgba(157, 78, 221, 0.8); }
      100% { box-shadow: 0 0 10px rgba(157, 78, 221, 0.5); }
    }
    
    @keyframes pulseGlow {
      0% { box-shadow: 0 0 5px rgba(157, 78, 221, 0.3); }
      50% { box-shadow: 0 0 25px rgba(157, 78, 221, 0.6), 0 0 40px rgba(157, 78, 221, 0.4); }
      100% { box-shadow: 0 0 5px rgba(157, 78, 221, 0.3); }
    }
    
    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    
    @keyframes float {
      0% { transform: translateY(0) scale(1); opacity: 0.6; }
      50% { transform: translateY(-20px) scale(1.2); opacity: 0.8; }
      100% { transform: translateY(0) scale(1); opacity: 0.6; }
    }
    
    body {
      font-family: var(--font-body);
      background: linear-gradient(135deg, #0f0f1a, #1a1a2e, #2c1a4d, #38195a);
      background-size: 400% 400%;
      animation: gradientShift 20s ease infinite;
      color: var(--text-color);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: var(--spacing-lg);
    }
    
    .container {
      max-width: 900px;
      margin: 0 auto;
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    .header {
      text-align: center;
      margin-bottom: var(--spacing-xl);
      animation: fadeIn 1s ease;
    }
    
    .header h1 {
      font-family: var(--font-heading);
      font-size: 2.5rem;
      margin-bottom: var(--spacing-md);
      color: white;
      text-shadow: var(--text-shadow);
      background: linear-gradient(135deg, #c2a0e5, #9d4edd);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    
    .header p {
      max-width: 600px;
      margin: 0 auto;
      line-height: 1.6;
      font-size: 1.1rem;
    }
    
    .generator {
      display: flex;
      flex-wrap: wrap;
      gap: var(--spacing-xl);
      width: 100%;
    }
    
    .input-section {
      flex: 1;
      min-width: 300px;
    }
    
    .output-section {
      flex: 1;
      min-width: 300px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    .input-card {
      background: linear-gradient(135deg, rgba(30, 30, 30, 0.7), rgba(15, 15, 15, 0.9));
      backdrop-filter: blur(10px);
      border-radius: var(--radius-lg);
      border: 1px solid rgba(157, 78, 221, 0.3);
      padding: var(--spacing-lg);
      width: 100%;
      box-shadow: var(--card-shadow);
      animation: fadeIn 0.8s ease;
    }
    
    .input-card h2 {
      font-family: var(--font-heading);
      font-size: 1.5rem;
      margin-bottom: var(--spacing-md);
      color: var(--primary-light);
    }
    
    .input-label {
      display: block;
      margin-bottom: var(--spacing-sm);
      color: var(--light-text);
    }
    
    .input-field {
      width: 100%;
      padding: var(--spacing-md);
      background: rgba(0, 0, 0, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: var(--radius-md);
      color: var(--text-color);
      font-family: var(--font-body);
      margin-bottom: var(--spacing-md);
      resize: vertical;
      min-height: 120px;
    }
    
    .input-field:focus {
      outline: none;
      border-color: var(--primary-light);
    }
    
    .generate-button {
      background: linear-gradient(135deg, var(--primary-color), var(--accent-color));
      color: white;
      border: none;
      border-radius: var(--radius-full);
      padding: var(--spacing-md) var(--spacing-lg);
      font-family: var(--font-heading);
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      width: 100%;
    }
    
    .generate-button:hover {
      transform: translateY(-3px);
      box-shadow: 0 7px 20px rgba(0, 0, 0, 0.4);
    }
    
    .symbol-container {
      position: relative;
      width: 300px;
      height: 300px;
      margin-bottom: var(--spacing-lg);
      border-radius: 50%;
      background: linear-gradient(135deg, rgba(30, 30, 30, 0.7), rgba(15, 15, 15, 0.9));
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: var(--card-shadow);
      animation: pulseGlow 4s infinite;
      overflow: hidden;
    }
    
    .symbol-wrapper {
      width: 240px;
      height: 240px;
      position: relative;
      z-index: 2;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .symbol-wrapper svg {
      width: 100%;
      height: 100%;
      overflow: visible;
    }
    
    .symbol-background {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background: radial-gradient(circle at center, rgba(106, 60, 181, 0.2), transparent 70%);
      z-index: 1;
    }
    
    .symbol-title {
      font-family: var(--font-heading);
      font-size: 1.3rem;
      margin-bottom: var(--spacing-sm);
      color: var(--primary-light);
    }
    
    .symbol-description {
      text-align: center;
      max-width: 300px;
      margin-bottom: var(--spacing-lg);
      font-style: italic;
      line-height: 1.6;
    }
    
    .action-buttons {
      display: flex;
      gap: var(--spacing-md);
      margin-top: var(--spacing-md);
    }
    
    .action-btn {
      background: rgba(255, 255, 255, 0.1);
      color: var(--light-text);
      border: none;
      border-radius: var(--radius-md);
      padding: var(--spacing-sm) var(--spacing-md);
      cursor: pointer;
      transition: all 0.3s ease;
      flex: 1;
      font-size: 0.9rem;
    }
    
    .action-btn:hover {
      background: rgba(255, 255, 255, 0.2);
      color: white;
    }
    
    .loading {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }
    
    .loading::after {
      content: '';
      width: 40px;
      height: 40px;
      border: 4px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border-top-color: var(--primary-light);
      animation: spin 1s linear infinite;
    }
    
    .hidden {
      display: none;
    }
    
    .cosmic-pattern {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      opacity: 0.1;
      pointer-events: none;
      z-index: 1;
    }
    
    .floating-particles {
      position: absolute;
      width: 100%;
      height: 100%;
      z-index: 1;
    }
    
    .particle {
      position: absolute;
      width: 6px;
      height: 6px;
      background: rgba(157, 78, 221, 0.6);
      border-radius: 50%;
      animation: float 5s infinite ease-in-out;
      pointer-events: none;
    }
    
    .particle:nth-child(1) { top: 10%; left: 20%; animation-delay: 0s; }
    .particle:nth-child(2) { top: 30%; left: 70%; animation-delay: 1s; }
    .particle:nth-child(3) { top: 50%; left: 30%; animation-delay: 2s; }
    .particle:nth-child(4) { top: 70%; left: 80%; animation-delay: 3s; }
    .particle:nth-child(5) { top: 20%; left: 50%; animation-delay: 4s; }
    .particle:nth-child(6) { top: 60%; left: 10%; animation-delay: 5s; }
    
    .symbol-type-selector {
      margin-bottom: var(--spacing-md);
    }
    
    .symbol-type-selector h3 {
      margin-bottom: var(--spacing-sm);
      color: var(--light-text);
    }
    
    .symbol-type-options {
      display: flex;
      gap: var(--spacing-sm);
    }
    
    .symbol-type-option {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: var(--radius-md);
      padding: var(--spacing-sm);
      cursor: pointer;
      transition: all 0.3s ease;
      flex: 1;
      text-align: center;
    }
    
    .symbol-type-option:hover {
      background: rgba(255, 255, 255, 0.2);
    }
    
    .symbol-type-option.active {
      background: rgba(106, 60, 181, 0.3);
      border-color: var(--primary-light);
    }
    
    @media (max-width: 768px) {
      .header h1 {
        font-size: 2rem;
      }
      
      .generator {
        flex-direction: column;
      }
      
      .symbol-container {
        width: 240px;
        height: 240px;
      }
      
      .symbol-wrapper {
        width: 200px;
        height: 200px;
      }
      
      .symbol-type-options {
        flex-direction: column;
      }
    }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;500;600;700&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>AeonAnima Symbol Generator</h1>
      <p>Enter a description of your inner essence, and behold as the cosmic forces generate a unique symbol that represents your AeonAnima signature.</p>
    </div>
    
    <div class="generator">
      <div class="input-section">
        <div class="input-card">
          <h2>Describe Your Essence</h2>
          <label for="description" class="input-label">Enter a description (traits, qualities, energy, etc.)</label>
          <textarea id="description" class="input-field" placeholder="Example: I am a calm and reflective person who loves exploring new ideas. I value harmony and deep connections. My energy is steady but intense when focused on something I'm passionate about."></textarea>
          
          <div class="symbol-type-selector">
            <h3>Symbol Style</h3>
            <div class="symbol-type-options">
              <div class="symbol-type-option active" data-type="cosmic-eye">Cosmic Eye</div>
              <div class="symbol-type-option" data-type="ethereal-mandala">Ethereal Mandala</div>
              <div class="symbol-type-option" data-type="celestial-sigil">Celestial Sigil</div>
            </div>
          </div>
          
          <button id="generate-btn" class="generate-button">Generate My Symbol</button>
          
          <div class="action-buttons">
            <button id="random-btn" class="action-btn">Random Description</button>
            <button id="clear-btn" class="action-btn">Clear</button>
          </div>
        </div>
      </div>
      
      <div class="output-section">
        <div class="symbol-container">
          <div id="loading" class="loading hidden"></div>
          <div class="symbol-background"></div>
          <svg class="cosmic-pattern" viewBox="0 0 300 300">
            <circle cx="150" cy="150" r="120" fill="none" stroke="#6A3CB5" stroke-width="1" />
          </svg>
          <div class="floating-particles">
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
          </div>
          <div class="symbol-wrapper" id="symbol-wrapper">
            <!-- Symbol will be generated here -->
          </div>
        </div>
        
        <h3 class="symbol-title" id="symbol-title">Your AeonAnima Awaits</h3>
        <p class="symbol-description" id="symbol-description">Enter your description and generate your unique cosmic symbol.</p>
        
        <div class="action-buttons">
          <button id="download-btn" class="generate-button" disabled>Download Symbol</button>
        </div>
      </div>
    </div>
  </div>
<script>
  document.addEventListener('DOMContentLoaded', function() {
  const generateBtn = document.getElementById('generate-btn');
  const randomBtn = document.getElementById('random-btn');
  const clearBtn = document.getElementById('clear-btn');
  const downloadBtn = document.getElementById('download-btn');
  const descriptionInput = document.getElementById('description');
  const symbolWrapper = document.getElementById('symbol-wrapper');
  const symbolTitle = document.getElementById('symbol-title');
  const symbolDescription = document.getElementById('symbol-description');
  const loading = document.getElementById('loading');
  const symbolTypeOptions = document.querySelectorAll('.symbol-type-option');
  
  let selectedSymbolType = 'cosmic-eye';
  
  // Set up symbol type selection
  symbolTypeOptions.forEach(option => {
    option.addEventListener('click', function() {
      symbolTypeOptions.forEach(opt => opt.classList.remove('active'));
      this.classList.add('active');
      selectedSymbolType = this.getAttribute('data-type');
    });
  });
  
  // Random descriptions for the "Random" button
  const randomDescriptions = [
    "I am deeply intuitive and value emotional connections. I tend to be introspective and find meaning in quiet moments of reflection.",
    "My energy is vibrant and enthusiastic. I love bringing people together and creating moments of joy and inspiration for others.",
    "I am methodical and thoughtful, preferring to analyze situations thoroughly before making decisions. I value truth and clarity above all.",
    "I have a creative and flexible approach to life, adapting easily to new situations. I'm drawn to beauty and artistic expression.",
    "I'm a natural protector with a strong sense of justice. I stand firm in my values and work diligently to support those around me.",
    "I balance intellectual curiosity with emotional awareness. I seek harmony in all things and believe in finding the middle path.",
    "My spirit is adventurous and I'm always seeking new horizons. I value freedom and authentic self-expression above all else.",
    "I find strength in transformation and resilience. I've navigated many challenges and emerged with deeper wisdom and compassion.",
    "I'm a visionary who sees possibilities where others see obstacles. I'm driven by a desire to create positive change in the world.",
    "I embody calm strength and steady determination. I prefer to listen more than speak and find wisdom in patience and observation.",
    "I am a dreamer with my head in the stars but my feet on the ground. I find balance between imagination and practicality.",
    "My essence vibrates with a gentle yet powerful energy. I'm drawn to spiritual exploration and connecting with the universal consciousness.",
    "I'm a catalyst for change, helping others discover their inner light. My energy is dynamic and transformative.",
    "I embody the element of water - fluid, adaptable, nurturing, and capable of both gentle calm and powerful force.",
    "My nature combines analytical precision with intuitive understanding. I see patterns where others see chaos.",
    "I'm a guardian of ancient wisdom, seeking to preserve knowledge while embracing innovation and progress.",
    "My soul resonates with celestial harmonies. I feel connected to the cosmos and draw inspiration from the stars.",
    "I am like fire - passionate, transformative, and illuminating. I bring warmth and light to those around me.",
    "I navigate between worlds, comfortable in the liminal spaces. I'm a bridge between different perspectives and realities.",
    "My essence is like the earth - grounded, nurturing, abundant, and enduring through all seasons of life."
  ];
  
  // Generate a random title based on the description
  function generateTitle(description) {
    const titles = [
      "Astral Wayfinder", "Ethereal Voyager", "Cosmic Harmonizer", "Celestial Guardian",
      "Mystic Navigator", "Quantum Pathfinder", "Stellar Resonator", "Luminous Oracle",
      "Aeon Weaver", "Empyreal Guide", "Nebula Dreamer", "Radiant Seeker",
      "Eternal Alchemist", "Sovereign Echo", "Infinite Wanderer", "Cosmic Seer",
      "Astral Architect", "Prismatic Sentinel", "Quantum Resonator", "Ethereal Oracle",
      "Celestial Voyager", "Chrono Guardian", "Stellar Alchemist", "Cosmic Harmonist",
      "Luminous Wayfinder", "Nebula Whisperer", "Empyreal Dreamer", "Divine Catalyst",
      "Astral Nomad", "Quantum Observer", "Ethereal Sentinel", "Prismatic Navigator"
    ];
    
    let seed = 0;
    for (let i = 0; i < description.length; i++) {
      seed += description.charCodeAt(i);
    }
    
    return titles[seed % titles.length];
  }
  
  // Generate a random subtitle based on the title and description
  function generateSubtitle(title, description) {
    const firstParts = [
      "Seeker of", "Weaver of", "Guardian of", "Curator of", 
      "Harbinger of", "Architect of", "Cultivator of", "Conduit of",
      "Keeper of", "Catalyst for", "Channeler of", "Defender of",
      "Emissary of", "Wellspring of", "Navigator of", "Vessel of"
    ];
    
    const secondParts = [
      "Inner Wisdom", "Universal Harmony", "Astral Truth", "Ethereal Light",
      "Cosmic Resonance", "Quantum Potential", "Divine Connection", "Infinite Possibility",
      "Temporal Balance", "Elemental Patterns", "Resonant Frequencies", "Celestial Insight",
      "Transcendent Knowledge", "Dimensional Gateways", "Awakened Consciousness", "Sacred Geometry",
      "Primordial Energy", "Eternal Truth", "Cosmic Equilibrium", "Divine Radiance",
      "Spiritual Evolution", "Quantum Harmony", "Stellar Memories", "Cosmic Revelation"
    ];
    
    let seed = 0;
    for (let i = 0; i < title.length + description.length; i++) {
      seed += (i < title.length) ? title.charCodeAt(i) : description.charCodeAt(i - title.length);
    }
    
    const firstPart = firstParts[seed % firstParts.length];
    const secondPart = secondParts[(seed * 13) % secondParts.length];
    
    return `${firstPart} ${secondPart}`;
  }
  
  // Generate the symbol based on the description and selected type
  function generateSymbol(description, symbolType) {
    // Create SVG element
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("viewBox", "0 0 240 240");
    svg.setAttribute("width", "240");
    svg.setAttribute("height", "240");
    
    // Seed for consistent randomness based on description
    let seed = 0;
    for (let i = 0; i < description.length; i++) {
      seed += description.charCodeAt(i);
    }
    
    function seededRandom() {
      seed = (seed * 9301 + 49297) % 233280;
      return seed / 233280;
    }
    
    // Define color palette
    const colorPalette = [
      '#6A3CB5', // Cosmic Purple
      '#9D4EDD', // Vibrant Amethyst
      '#3498DB', // Celestial Blue
      '#E74C3C', // Stellar Red
      '#2ECC71', // Nebula Green
      '#F1C40F', // Solar Yellow
      '#8E44AD', // Galactic Violet
      '#1ABC9C'  // Aurora Teal
    ];
    
    // Create defs for gradients and filters
    const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
    
    // Add glow filter
    const glowFilter = document.createElementNS("http://www.w3.org/2000/svg", "filter");
    glowFilter.setAttribute("id", "glow");
    const feGaussianBlur = document.createElementNS("http://www.w3.org/2000/svg", "feGaussianBlur");
    feGaussianBlur.setAttribute("stdDeviation", "2");
    feGaussianBlur.setAttribute("result", "blur");
    const feMerge = document.createElementNS("http://www.w3.org/2000/svg", "feMerge");
    const feMergeNode1 = document.createElementNS("http://www.w3.org/2000/svg", "feMergeNode");
    feMergeNode1.setAttribute("in", "blur");
    const feMergeNode2 = document.createElementNS("http://www.w3.org/2000/svg", "feMergeNode");
    feMergeNode2.setAttribute("in", "SourceGraphic");
    feMerge.appendChild(feMergeNode1);
    feMerge.appendChild(feMergeNode2);
    glowFilter.appendChild(feGaussianBlur);
    glowFilter.appendChild(feMerge);
    defs.appendChild(glowFilter);
    
    // Create radial gradient
    const radialGradient = document.createElementNS("http://www.w3.org/2000/svg", "radialGradient");
    radialGradient.setAttribute("id", "centerGlow");
    radialGradient.setAttribute("cx", "50%");
    radialGradient.setAttribute("cy", "50%");
    radialGradient.setAttribute("r", "50%");
    
    const stop1 = document.createElementNS("http://www.w3.org/2000/svg", "stop");
    stop1.setAttribute("offset", "0%");
    stop1.setAttribute("stop-color", colorPalette[Math.floor(seededRandom() * colorPalette.length)]);
    stop1.setAttribute("stop-opacity", "0.6");
    
    const stop2 = document.createElementNS("http://www.w3.org/2000/svg", "stop");
    stop2.setAttribute("offset", "100%");
    stop2.setAttribute("stop-color", colorPalette[Math.floor(seededRandom() * colorPalette.length)]);
    stop2.setAttribute("stop-opacity", "0");
    
    radialGradient.appendChild(stop1);
    radialGradient.appendChild(stop2);
    defs.appendChild(radialGradient);
    
    // Create linear gradient for paths
    const linearGradient = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient");
    linearGradient.setAttribute("id", "pathGradient");
    linearGradient.setAttribute("x1", "0%");
    linearGradient.setAttribute("y1", "0%");
    linearGradient.setAttribute("x2", "100%");
    linearGradient.setAttribute("y2", "100%");
    
    const stop3 = document.createElementNS("http://www.w3.org/2000/svg", "stop");
    stop3.setAttribute("offset", "0%");
    stop3.setAttribute("stop-color", colorPalette[Math.floor(seededRandom() * colorPalette.length)]);
    
    const stop4 = document.createElementNS("http://www.w3.org/2000/svg", "stop");
    stop4.setAttribute("offset", "100%");
    stop4.setAttribute("stop-color", colorPalette[Math.floor(seededRandom() * colorPalette.length)]);
    
    linearGradient.appendChild(stop3);
    linearGradient.appendChild(stop4);
    defs.appendChild(linearGradient);
    
    svg.appendChild(defs);
    
    // Get personality traits from description
    const lowercaseDesc = description.toLowerCase();
    const isCreative = lowercaseDesc.includes('creative') || lowercaseDesc.includes('artistic') || lowercaseDesc.includes('imagination');
    const isIntense = lowercaseDesc.includes('intense') || lowercaseDesc.includes('passionate') || lowercaseDesc.includes('driven');
    const isCalm = lowercaseDesc.includes('calm') || lowercaseDesc.includes('peaceful') || lowercaseDesc.includes('serene');
    const isAnalytical = lowercaseDesc.includes('analytical') || lowercaseDesc.includes('logical') || lowercaseDesc.includes('methodical');
    const isEmotional = lowercaseDesc.includes('emotional') || lowercaseDesc.includes('sensitive') || lowercaseDesc.includes('empathetic');
    const isOutgoing = lowercaseDesc.includes('outgoing') || lowercaseDesc.includes('extrovert') || lowercaseDesc.includes('social');
    const isQuiet = lowercaseDesc.includes('quiet') || lowercaseDesc.includes('introvert') || lowercaseDesc.includes('reserved');
    const isWater = lowercaseDesc.includes('water') || lowercaseDesc.includes('fluid') || lowercaseDesc.includes('flow');
    const isFire = lowercaseDesc.includes('fire') || lowercaseDesc.includes('passion') || lowercaseDesc.includes('flame');
    const isEarth = lowercaseDesc.includes('earth') || lowercaseDesc.includes('ground') || lowercaseDesc.includes('solid');
    const isAir = lowercaseDesc.includes('air') || lowercaseDesc.includes('wind') || lowercaseDesc.includes('breeze');
    const isSpiritual = lowercaseDesc.includes('spiritual') || lowercaseDesc.includes('mystic') || lowercaseDesc.includes('cosmic');
    // Added isComplex as a derived trait
    const isComplex = isCreative || isIntense || isAnalytical || lowercaseDesc.includes('complex') || lowercaseDesc.includes('detail');
    
    // Get a color from the palette based on the description
    let mainColor = colorPalette[Math.floor(seededRandom() * colorPalette.length)];
    
    // Adjust color based on traits
    if (isIntense || isFire) {
      // Prefer vibrant colors for intense personalities
      mainColor = ['#E74C3C', '#9D4EDD', '#F1C40F'][Math.floor(seededRandom() * 3)];
    } else if (isCalm || isWater) {
      // Prefer cooler tones for calm personalities
      mainColor = ['#3498DB', '#1ABC9C', '#6A3CB5'][Math.floor(seededRandom() * 3)];
    } else if (isEarth) {
      mainColor = ['#2ECC71', '#F1C40F', '#E67E22'][Math.floor(seededRandom() * 3)];
    } else if (isAir || isSpiritual) {
      mainColor = ['#3498DB', '#8E44AD', '#9B59B6'][Math.floor(seededRandom() * 3)];
    }
    
    // Line thickness based on personality
    let lineThickness;
    if (isOutgoing || isIntense || isFire) {
      lineThickness = 2 + seededRandom() * 0.8; // Thicker lines for outgoing/intense
    } else if (isAnalytical || isQuiet || isEarth) {
      lineThickness = 0.8 + seededRandom() * 0.6; // Thinner, more precise lines
    } else {
      lineThickness = 1.2 + seededRandom() * 0.8; // Medium range
    }
    
    // Background glow circle
    const backgroundGlow = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    backgroundGlow.setAttribute("cx", "120");
    backgroundGlow.setAttribute("cy", "120");
    backgroundGlow.setAttribute("r", "110");
    backgroundGlow.setAttribute("fill", "url(#centerGlow)");
    backgroundGlow.setAttribute("opacity", "0.3");
    svg.appendChild(backgroundGlow);
    
    // Outer circle
    const outerCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    outerCircle.setAttribute("cx", "120");
    outerCircle.setAttribute("cy", "120");
    outerCircle.setAttribute("r", "112");
    outerCircle.setAttribute("stroke", mainColor);
    outerCircle.setAttribute("stroke-width", lineThickness/2);
    outerCircle.setAttribute("fill", "none");
    outerCircle.setAttribute("filter", "url(#glow)");
    svg.appendChild(outerCircle);
    
    // Now create the specific symbol based on the selected type
    if (symbolType === 'cosmic-eye') {
      createCosmicEyeSymbol(svg, mainColor, lineThickness, seededRandom, 
        isCreative, isIntense, isCalm, isAnalytical, isEmotional, isOutgoing, isQuiet);
    } else if (symbolType === 'ethereal-mandala') {
      createEtherealMandalaSymbol(svg, mainColor, lineThickness, seededRandom, 
        isCreative, isIntense, isCalm, isAnalytical, isEmotional, isOutgoing, isQuiet, isComplex);
    } else if (symbolType === 'celestial-sigil') {
      createCelestialSigilSymbol(svg, mainColor, lineThickness, seededRandom, 
        isCreative, isIntense, isCalm, isAnalytical, isEmotional, isOutgoing, isQuiet, isComplex);
    }
    
    return svg;
  }
  
  // Function to create the Cosmic Eye symbol
  function createCosmicEyeSymbol(svg, mainColor, lineThickness, seededRandom, 
      isCreative, isIntense, isCalm, isAnalytical, isEmotional, isOutgoing, isQuiet) {
    
    // Adjust viewBox center, making the eye slightly off-center for some personalities
    let centerX = 120;
    let centerY = 120;
    const offsetX = (isCreative || isEmotional) ? -2 + seededRandom() * 4 : 0;
    const offsetY = (isCreative || isEmotional) ? -1 + seededRandom() * 2 : 0;
    centerX += offsetX;
    centerY += offsetY;
    
    // Eye shape variables
    const eyeWidth = 100 * (0.8 + seededRandom() * 0.4); // Variable width
    const eyeHeight = 50 * (0.8 + seededRandom() * 0.5); // Variable height
    
    // Eye outline shape varies based on personality
    let eyePathD;
    if (isCalm || isAnalytical) {
      // More symmetric, regular eye shape
      eyePathD = `M${centerX - eyeWidth/2},${centerY} C${centerX - eyeWidth/2},${centerY} ${centerX - eyeWidth/4},${centerY - eyeHeight/2} ${centerX},${centerY - eyeHeight/2} C${centerX + eyeWidth/4},${centerY - eyeHeight/2} ${centerX + eyeWidth/2},${centerY} ${centerX + eyeWidth/2},${centerY} C${centerX + eyeWidth/2},${centerY} ${centerX + eyeWidth/4},${centerY + eyeHeight/2} ${centerX},${centerY + eyeHeight/2} C${centerX - eyeWidth/4},${centerY + eyeHeight/2} ${centerX - eyeWidth/2},${centerY} ${centerX - eyeWidth/2},${centerY}`;
    } else if (isCreative || isEmotional) {
      // More expressive, slightly asymmetric eye
      const leftSkew = -2 + seededRandom() * 4;
      const rightSkew = -2 + seededRandom() * 4;
      const topSkew = -1 + seededRandom() * 2;
      const bottomSkew = -1 + seededRandom() * 2;
      
      eyePathD = `M${centerX - eyeWidth/2},${centerY} C${centerX - eyeWidth/2},${centerY} ${centerX - eyeWidth/4 + leftSkew},${centerY - eyeHeight/2 + topSkew} ${centerX},${centerY - eyeHeight/2} C${centerX + eyeWidth/4 + rightSkew},${centerY - eyeHeight/2 + topSkew} ${centerX + eyeWidth/2},${centerY} ${centerX + eyeWidth/2},${centerY} C${centerX + eyeWidth/2},${centerY} ${centerX + eyeWidth/4 + rightSkew},${centerY + eyeHeight/2 + bottomSkew} ${centerX},${centerY + eyeHeight/2} C${centerX - eyeWidth/4 + leftSkew},${centerY + eyeHeight/2 + bottomSkew} ${centerX - eyeWidth/2},${centerY} ${centerX - eyeWidth/2},${centerY}`;
    } else if (isIntense) {
      // More pointed, intense eye shape
      eyePathD = `M${centerX - eyeWidth/2},${centerY} C${centerX - eyeWidth/2},${centerY} ${centerX - eyeWidth/4},${centerY - eyeHeight/1.8} ${centerX},${centerY - eyeHeight/2} C${centerX + eyeWidth/4},${centerY - eyeHeight/1.8} ${centerX + eyeWidth/2},${centerY} ${centerX + eyeWidth/2},${centerY} C${centerX + eyeWidth/2},${centerY} ${centerX + eyeWidth/4},${centerY + eyeHeight/1.8} ${centerX},${centerY + eyeHeight/2} C${centerX - eyeWidth/4},${centerY + eyeHeight/1.8} ${centerX - eyeWidth/2},${centerY} ${centerX - eyeWidth/2},${centerY}`;
    } else {
      // Default eye shape with slight randomness
      const leftVar = -1 + seededRandom() * 2;
      const rightVar = -1 + seededRandom() * 2;
      const topVar = -0.5 + seededRandom() * 1;
      const bottomVar = -0.5 + seededRandom() * 1;
      
      eyePathD = `M${centerX - eyeWidth/2},${centerY} C${centerX - eyeWidth/2},${centerY} ${centerX - eyeWidth/4 + leftVar},${centerY - eyeHeight/2 + topVar} ${centerX},${centerY - eyeHeight/2} C${centerX + eyeWidth/4 + rightVar},${centerY - eyeHeight/2 + topVar} ${centerX + eyeWidth/2},${centerY} ${centerX + eyeWidth/2},${centerY} C${centerX + eyeWidth/2},${centerY} ${centerX + eyeWidth/4 + rightVar},${centerY + eyeHeight/2 + bottomVar} ${centerX},${centerY + eyeHeight/2} C${centerX - eyeWidth/4 + leftVar},${centerY + eyeHeight/2 + bottomVar} ${centerX - eyeWidth/2},${centerY} ${centerX - eyeWidth/2},${centerY}`;
    }
    
    // Eye outline
    const eyePath = document.createElementNS("http://www.w3.org/2000/svg", "path");
    eyePath.setAttribute("d", eyePathD);
    eyePath.setAttribute("stroke", mainColor);
    eyePath.setAttribute("stroke-width", lineThickness);
    eyePath.setAttribute("fill", "none");
    eyePath.setAttribute("filter", "url(#glow)");
    svg.appendChild(eyePath);
    
    // Iris size and position
    let irisSize = 15;
    if (isIntense || isOutgoing) {
      irisSize = 20 + seededRandom() * 5; // Larger iris for intense/outgoing
    } else if (isAnalytical || isQuiet) {
      irisSize = 12 + seededRandom() * 4; // Smaller iris for analytical/quiet
    } else {
      irisSize = 16 + seededRandom() * 5; // Medium range with more variation
    }
    
    // Iris position can be slightly off-center for some personalities
    let irisCenterX = centerX;
    let irisCenterY = centerY;
    
    if (!isCalm && !isAnalytical) {
      irisCenterX += (-1 + seededRandom() * 2) * 5; // More random positioning
      irisCenterY += (-1 + seededRandom() * 2) * 3;
    }
    
    // Iris
    const iris = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    iris.setAttribute("cx", irisCenterX);
    iris.setAttribute("cy", irisCenterY);
    iris.setAttribute("r", irisSize);
    iris.setAttribute("stroke", mainColor);
    iris.setAttribute("stroke-width", lineThickness);
    iris.setAttribute("fill", "none");
    iris.setAttribute("filter", "url(#glow)");
    svg.appendChild(iris);
    
    // Pupil size and position
    let pupilSize = irisSize * 0.4;
    let pupilCenterX = irisCenterX;
    let pupilCenterY = irisCenterY;
    
    // Adjust pupil based on personality
    if (isIntense) {
      pupilSize = irisSize * 0.5; // Larger pupil for intense
    } else if (isCalm) {
      pupilSize = irisSize * 0.3; // Smaller pupil for calm
    }
    
    // Pupil can be off-center from the iris for some personalities
    if (isCreative || isEmotional) {
      pupilCenterX += (-0.5 + seededRandom() * 1) * 3;
      pupilCenterY += (-0.5 + seededRandom() * 1) * 2;
    }
    
    // Different pupil shapes based on personality
    const pupilType = Math.floor(seededRandom() * 3); // 0: circle, 1: oval, 2: slit
    
    if (pupilType === 0 || isCalm || isEmotional) {
      // Regular circle pupil (most common, especially for calm or emotional)
      const pupil = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      pupil.setAttribute("cx", pupilCenterX);
      pupil.setAttribute("cy", pupilCenterY);
      pupil.setAttribute("r", pupilSize);
      pupil.setAttribute("fill", mainColor);
      pupil.setAttribute("filter", "url(#glow)");
      svg.appendChild(pupil);
    } else if (pupilType === 1 || isCreative) {
      // Oval pupil (common for creative types)
      const pupil = document.createElementNS("http://www.w3.org/2000/svg", "ellipse");
      pupil.setAttribute("cx", pupilCenterX);
      pupil.setAttribute("cy", pupilCenterY);
      pupil.setAttribute("rx", pupilSize * 1.3);
      pupil.setAttribute("ry", pupilSize * 0.7);
      pupil.setAttribute("fill", mainColor);
      pupil.setAttribute("filter", "url(#glow)");
      // Random rotation
      const rotation = seededRandom() * 180;
      pupil.setAttribute("transform", `rotate(${rotation}, ${pupilCenterX}, ${pupilCenterY})`);
      svg.appendChild(pupil);
    } else if (pupilType === 2 || isIntense || isAnalytical) {
      // Slit pupil (less common, for intense or analytical types)
      const pupil = document.createElementNS("http://www.w3.org/2000/svg", "ellipse");
      pupil.setAttribute("cx", pupilCenterX);
      pupil.setAttribute("cy", pupilCenterY);
      pupil.setAttribute("rx", pupilSize * 0.7);
      pupil.setAttribute("ry", pupilSize * 1.8);
      pupil.setAttribute("fill", mainColor);
      pupil.setAttribute("filter", "url(#glow)");
      // Random rotation
      const rotation = seededRandom() * 180;
      pupil.setAttribute("transform", `rotate(${rotation}, ${pupilCenterX}, ${pupilCenterY})`);
      svg.appendChild(pupil);
    }
    
    // Add subtle orbital rings around the eye for cosmic feel
    const numOrbits = 2 + Math.floor(seededRandom() * 3); // 2-4 orbital rings
    for (let i = 0; i < numOrbits; i++) {
      const orbitRadius = 60 + i * 15 + seededRandom() * 10;
      const orbitEllipse = document.createElementNS("http://www.w3.org/2000/svg", "ellipse");
      orbitEllipse.setAttribute("cx", 120);
      orbitEllipse.setAttribute("cy", 120);
      orbitEllipse.setAttribute("rx", orbitRadius);
      orbitEllipse.setAttribute("ry", orbitRadius * (0.8 + seededRandom() * 0.4));
      orbitEllipse.setAttribute("stroke", mainColor);
      orbitEllipse.setAttribute("stroke-width", 0.5);
      orbitEllipse.setAttribute("fill", "none");
      orbitEllipse.setAttribute("opacity", 0.5 - (i * 0.1));
      
      // Random rotation for the orbit
      const rotation = seededRandom() * 180;
      orbitEllipse.setAttribute("transform", `rotate(${rotation}, 120, 120)`);
      
      svg.appendChild(orbitEllipse);
      
      // Add a small "planet" or "star" on some of the orbits
      if (seededRandom() > 0.3) {
        const orbitPosition = seededRandom() * 360;
        const planetX = 120 + Math.cos(orbitPosition * Math.PI / 180) * orbitRadius;
        const planetY = 120 + Math.sin(orbitPosition * Math.PI / 180) * (orbitRadius * (0.8 + seededRandom() * 0.4));
        const planet = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        planet.setAttribute("cx", planetX);
        planet.setAttribute("cy", planetY);
        planet.setAttribute("r", 1 + seededRandom() * 2);
        planet.setAttribute("fill", mainColor);
        planet.setAttribute("filter", "url(#glow)");
        svg.appendChild(planet);
      }
    }
  }
  
  // Function to create the Ethereal Mandala symbol
  function createEtherealMandalaSymbol(svg, mainColor, lineThickness, seededRandom,
      isCreative, isIntense, isCalm, isAnalytical, isEmotional, isOutgoing, isQuiet, isComplex) {
    
    const centerX = 120;
    const centerY = 120;
    const baseRadius = 80;
    
    // Center circle
    const centerCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    centerCircle.setAttribute("cx", centerX);
    centerCircle.setAttribute("cy", centerY);
    centerCircle.setAttribute("r", baseRadius * 0.25);
    centerCircle.setAttribute("stroke", mainColor);
    centerCircle.setAttribute("stroke-width", lineThickness);
    centerCircle.setAttribute("fill", "none");
    centerCircle.setAttribute("filter", "url(#glow)");
    svg.appendChild(centerCircle);
    
    // Determine number of petals based on personality
    let numPetals = 8; // Default
    if (isCreative || isEmotional) {
      numPetals = 9 + Math.floor(seededRandom() * 3); // 9-11
    } else if (isAnalytical || isCalm) {
      numPetals = 6 + Math.floor(seededRandom() * 3); // 6-8
    } else if (isIntense) {
      numPetals = 12 + Math.floor(seededRandom() * 4); // 12-15
    }
    
    // Create the main mandala petals
    for (let i = 0; i < numPetals; i++) {
      const angle = (i / numPetals) * 2 * Math.PI;
      const petalLength = baseRadius * (0.6 + seededRandom() * 0.3);
      
      // Petal width varies by personality
      let petalWidth;
      if (isIntense || isOutgoing) {
        petalWidth = 0.4 + seededRandom() * 0.3; // Wider petals
      } else if (isCalm || isQuiet) {
        petalWidth = 0.2 + seededRandom() * 0.2; // Narrower petals
      } else {
        petalWidth = 0.3 + seededRandom() * 0.2; // Medium width
      }
      
      // Calculate control points for the petal curve
      const innerX = centerX + Math.cos(angle) * baseRadius * 0.25;
      const innerY = centerY + Math.sin(angle) * baseRadius * 0.25;
      const outerX = centerX + Math.cos(angle) * petalLength;
      const outerY = centerY + Math.sin(angle) * petalLength;
      
      const cp1Angle = angle + (Math.PI/2) * petalWidth;
      const cp2Angle = angle - (Math.PI/2) * petalWidth;
      
      const cpLength = petalLength * 0.8;
      const cp1X = centerX + Math.cos(cp1Angle) * cpLength;
      const cp1Y = centerY + Math.sin(cp1Angle) * cpLength;
      const cp2X = centerX + Math.cos(cp2Angle) * cpLength;
      const cp2Y = centerY + Math.sin(cp2Angle) * cpLength;
      
      // Create the petal path
      const petal = document.createElementNS("http://www.w3.org/2000/svg", "path");
      petal.setAttribute("d", `M${innerX},${innerY} Q${cp1X},${cp1Y} ${outerX},${outerY} Q${cp2X},${cp2Y} ${innerX},${innerY}`);
      petal.setAttribute("stroke", mainColor);
      petal.setAttribute("stroke-width", lineThickness);
      petal.setAttribute("fill", "none");
      petal.setAttribute("filter", "url(#glow)");
      svg.appendChild(petal);
      
      // Add small circles at the petal tips for some personality types
      if ((isCreative || isEmotional) && seededRandom() > 0.4) {
        const tipCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        tipCircle.setAttribute("cx", outerX);
        tipCircle.setAttribute("cy", outerY);
        tipCircle.setAttribute("r", 2 + seededRandom() * 2);
        tipCircle.setAttribute("fill", mainColor);
        tipCircle.setAttribute("filter", "url(#glow)");
        svg.appendChild(tipCircle);
      }
    }
    
    // Add a subtle eye element in the center for all mandala types
    const eyeRadius = baseRadius * 0.15;
    const eyeEllipse = document.createElementNS("http://www.w3.org/2000/svg", "ellipse");
    eyeEllipse.setAttribute("cx", centerX);
    eyeEllipse.setAttribute("cy", centerY);
    eyeEllipse.setAttribute("rx", eyeRadius);
    eyeEllipse.setAttribute("ry", eyeRadius * 0.7);
    eyeEllipse.setAttribute("stroke", mainColor);
    eyeEllipse.setAttribute("stroke-width", lineThickness * 0.8);
    eyeEllipse.setAttribute("fill", "none");
    eyeEllipse.setAttribute("filter", "url(#glow)");
    svg.appendChild(eyeEllipse);
    
    // Add a small pupil in the center
    const pupil = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    pupil.setAttribute("cx", centerX);
    pupil.setAttribute("cy", centerY);
    pupil.setAttribute("r", eyeRadius * 0.3);
    pupil.setAttribute("fill", mainColor);
    pupil.setAttribute("filter", "url(#glow)");
    svg.appendChild(pupil);
    
    // Add connecting lines between petals for more complex mandalas
    if (isCreative || isComplex || seededRandom() > 0.6) {
      for (let i = 0; i < numPetals; i+=2) {
        const angle1 = (i / numPetals) * 2 * Math.PI;
        const angle2 = ((i+1) / numPetals) * 2 * Math.PI;
        
        const x1 = centerX + Math.cos(angle1) * baseRadius * 0.7;
        const y1 = centerY + Math.sin(angle1) * baseRadius * 0.7;
        const x2 = centerX + Math.cos(angle2) * baseRadius * 0.7;
        const y2 = centerY + Math.sin(angle2) * baseRadius * 0.7;
        
        const connector = document.createElementNS("http://www.w3.org/2000/svg", "path");
        connector.setAttribute("d", `M${x1},${y1} Q${centerX},${centerY} ${x2},${y2}`);
        connector.setAttribute("stroke", mainColor);
        connector.setAttribute("stroke-width", lineThickness * 0.5);
        connector.setAttribute("fill", "none");
        connector.setAttribute("opacity", "0.6");
        svg.appendChild(connector);
      }
    }
    
    // Add outer ring for stability/grounding
    const outerRing = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    outerRing.setAttribute("cx", centerX);
    outerRing.setAttribute("cy", centerY);
    outerRing.setAttribute("r", baseRadius * 0.95);
    outerRing.setAttribute("stroke", mainColor);
    outerRing.setAttribute("stroke-width", lineThickness * 0.7);
    outerRing.setAttribute("stroke-dasharray", isCreative || isEmotional ? "1,3" : "");
    outerRing.setAttribute("fill", "none");
    outerRing.setAttribute("opacity", "0.7");
    svg.appendChild(outerRing);
  }
  
  // Function to create the Celestial Sigil symbol
  function createCelestialSigilSymbol(svg, mainColor, lineThickness, seededRandom,
      isCreative, isIntense, isCalm, isAnalytical, isEmotional, isOutgoing, isQuiet, isComplex) {
    
    const centerX = 120;
    const centerY = 120;
    
    // Number of lines and complexity varies by personality
    let numLines = 5; // Default
    if (isCreative || isComplex) {
      numLines = 7 + Math.floor(seededRandom() * 3); // 7-9 lines for creative
    } else if (isAnalytical) {
      numLines = 4 + Math.floor(seededRandom() * 3); // 4-6 lines for analytical (more structured)
    } else if (isCalm || isQuiet) {
      numLines = 3 + Math.floor(seededRandom() * 2); // 3-4 lines for calm (simpler)
    }
    
    // Create points for the sigil lines
    const points = [];
    
    // Start with center point
    points.push({x: centerX, y: centerY});
    
    // Add main points in a semi-random pattern, influenced by personality
    for (let i = 0; i < numLines; i++) {
      let distance, angle;
      
      if (isAnalytical || isCalm) {
        // More structured, evenly spaced points
        angle = (i / numLines) * 2 * Math.PI;
        distance = 50 + seededRandom() * 30;
      } else if (isCreative || isEmotional) {
        // More random, varied placement
        angle = seededRandom() * 2 * Math.PI;
        distance = 30 + seededRandom() * 60;
      } else {
        // Balanced randomness
        angle = (i / numLines) * 2 * Math.PI + (seededRandom() * 0.5);
        distance = 40 + seededRandom() * 40;
      }
      
      const x = centerX + Math.cos(angle) * distance;
      const y = centerY + Math.sin(angle) * distance;
      
      points.push({x, y});
    }
    
    // Add an eye shaped element somewhere in the sigil
    let eyeX, eyeY;
    
    if (isCalm || isAnalytical) {
      // Eye near center for balanced personalities
      eyeX = centerX + (-10 + seededRandom() * 20);
      eyeY = centerY + (-10 + seededRandom() * 20);
    } else {
      // Eye can be anywhere in the symbol for creative types
      const eyeAngle = seededRandom() * 2 * Math.PI;
      const eyeDistance = 20 + seededRandom() * 50;
      eyeX = centerX + Math.cos(eyeAngle) * eyeDistance;
      eyeY = centerY + Math.sin(eyeAngle) * eyeDistance;
    }
    
    // Eye size varies by personality
    let eyeWidth = 20 + seededRandom() * 10;
    let eyeHeight = eyeWidth * 0.5;
    
    if (isIntense || isOutgoing) {
      eyeWidth *= 1.2; // Larger eye
    } else if (isQuiet || isCalm) {
      eyeWidth *= 0.8; // Smaller eye
    }
    
    // Create the eye shape
    const eye = document.createElementNS("http://www.w3.org/2000/svg", "ellipse");
    eye.setAttribute("cx", eyeX);
    eye.setAttribute("cy", eyeY);
    eye.setAttribute("rx", eyeWidth / 2);
    eye.setAttribute("ry", eyeHeight / 2);
    eye.setAttribute("stroke", mainColor);
    eye.setAttribute("stroke-width", lineThickness);
    eye.setAttribute("fill", "none");
    eye.setAttribute("filter", "url(#glow)");
    svg.appendChild(eye);
    
    // Add a pupil
    const pupil = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    pupil.setAttribute("cx", eyeX);
    pupil.setAttribute("cy", eyeY);
    pupil.setAttribute("r", eyeHeight / 3);
    pupil.setAttribute("fill", mainColor);
    pupil.setAttribute("filter", "url(#glow)");
    svg.appendChild(pupil);
    
    // Add eye to the points list
    points.push({x: eyeX, y: eyeY});
    
    // Create connecting lines between points to form the sigil
    const lineSequence = [];
    const usedConnections = new Set();
    
    // Start with a connection to the center
    lineSequence.push(0); // center point index
    
    // Generate a sequence of connections
    for (let i = 0; i < numLines + 2; i++) {
      // Find available connections
      const currentIndex = lineSequence[lineSequence.length - 1];
      const availablePoints = [];
      
      for (let j = 0; j < points.length; j++) {
        if (j !== currentIndex && !usedConnections.has(`${currentIndex}-${j}`)) {
          availablePoints.push(j);
        }
      }
      
      if (availablePoints.length === 0) break;
      
      // Select the next point based on personality traits
      let nextIndex;
      if (isAnalytical || isCalm) {
        // More structured, methodical connections for analytical types
        nextIndex = availablePoints[0]; // Predictable choice
      } else if (isCreative || isEmotional) {
        // More random connections for creative types
        nextIndex = availablePoints[Math.floor(seededRandom() * availablePoints.length)];
      } else {
        // Balanced approach
        nextIndex = availablePoints[Math.floor(seededRandom() * Math.min(3, availablePoints.length))];
      }
      
      lineSequence.push(nextIndex);
      usedConnections.add(`${currentIndex}-${nextIndex}`);
      usedConnections.add(`${nextIndex}-${currentIndex}`); // Prevent reverse connection too
    }
    
    // Draw the lines between points
    for (let i = 0; i < lineSequence.length - 1; i++) {
      const startIndex = lineSequence[i];
      const endIndex = lineSequence[i + 1];
      
      const startPoint = points[startIndex];
      const endPoint = points[endIndex];
      
      // Create line with a slight curve for more organic feel
      const line = document.createElementNS("http://www.w3.org/2000/svg", "path");
      
      // Straight lines for analytical, curves for creative
      if (isAnalytical) {
        line.setAttribute("d", `M${startPoint.x},${startPoint.y} L${endPoint.x},${endPoint.y}`);
      } else {
        const controlX = (startPoint.x + endPoint.x) / 2 + (-10 + seededRandom() * 20);
        const controlY = (startPoint.y + endPoint.y) / 2 + (-10 + seededRandom() * 20);
        line.setAttribute("d", `M${startPoint.x},${startPoint.y} Q${controlX},${controlY} ${endPoint.x},${endPoint.y}`);
      }
      
      line.setAttribute("stroke", mainColor);
      line.setAttribute("stroke-width", lineThickness);
      line.setAttribute("fill", "none");
      line.setAttribute("filter", "url(#glow)");
      svg.appendChild(line);
      
      // Add small nodes at some of the connection points
      if (seededRandom() > 0.6) {
        const node = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        node.setAttribute("cx", endPoint.x);
        node.setAttribute("cy", endPoint.y);
        node.setAttribute("r", 2 + seededRandom() * 2);
        node.setAttribute("fill", mainColor);
        node.setAttribute("filter", "url(#glow)");
        svg.appendChild(node);
      }
    }
    
    // Add some small constellation-like dots
    const numDots = 10 + Math.floor(seededRandom() * 15);
    for (let i = 0; i < numDots; i++) {
      const angle = seededRandom() * 2 * Math.PI;
      const distance = 30 + seededRandom() * 70;
      
      const dotX = centerX + Math.cos(angle) * distance;
      const dotY = centerY + Math.sin(angle) * distance;
      
      // Skip dots that are too close to lines
      let tooClose = false;
      for (let j = 0; j < lineSequence.length - 1; j++) {
        const startPoint = points[lineSequence[j]];
        const endPoint = points[lineSequence[j + 1]];
        
        // Calculate distance from dot to line
        const dist = distanceToLine(dotX, dotY, startPoint.x, startPoint.y, endPoint.x, endPoint.y);
        if (dist < 10) {
          tooClose = true;
          break;
        }
      }
      
      if (!tooClose) {
        const dot = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        dot.setAttribute("cx", dotX);
        dot.setAttribute("cy", dotY);
        dot.setAttribute("r", 0.5 + seededRandom() * 1.5);
        dot.setAttribute("fill", mainColor);
        dot.setAttribute("filter", "url(#glow)");
        svg.appendChild(dot);
      }
    }
  }
  
  // Helper function to calculate distance from point to line
  function distanceToLine(x, y, x1, y1, x2, y2) {
    const A = x - x1;
    const B = y - y1;
    const C = x2 - x1;
    const D = y2 - y1;
    
    const dot = A * C + B * D;
    const lenSq = C * C + D * D;
    let param = -1;
    
    if (lenSq !== 0) {
      param = dot / lenSq;
    }
    
    let xx, yy;
    
    if (param < 0) {
      xx = x1;
      yy = y1;
    } else if (param > 1) {
      xx = x2;
      yy = y2;
    } else {
      xx = x1 + param * C;
      yy = y1 + param * D;
    }
    
    const dx = x - xx;
    const dy = y - yy;
    
    return Math.sqrt(dx * dx + dy * dy);
  }
  
  // Generate a random description
  function getRandomDescription() {
    const randomIndex = Math.floor(Math.random() * randomDescriptions.length);
    return randomDescriptions[randomIndex];
  }
  
  // Download SVG
  function downloadSVG() {
    const svg = symbolWrapper.querySelector('svg');
    if (!svg) return;
    const svgData = new XMLSerializer().serializeToString(svg);
    const svgBlob = new Blob([svgData], {type: "image/svg+xml;charset=utf-8"});
    const svgUrl = URL.createObjectURL(svgBlob);
    
    const downloadLink = document.createElement("a");
    downloadLink.href = svgUrl;
    downloadLink.download = "aeonanima-symbol.svg";
    document.body.appendChild(downloadLink);
    downloadLink.click();
    document.body.removeChild(downloadLink);
    URL.revokeObjectURL(svgUrl);
  }
  
  // Event listeners
  generateBtn.addEventListener('click', function() {
    const description = descriptionInput.value.trim();
    
    if (description === '') {
      alert('Please enter a description of your essence.');
      return;
    }
    
    loading.classList.remove('hidden');
    
    setTimeout(() => {
      symbolWrapper.innerHTML = '';
      
      const symbol = generateSymbol(description, selectedSymbolType);
      symbolWrapper.appendChild(symbol);
      
      const title = generateTitle(description);
      symbolTitle.textContent = title;
      
      const subtitle = generateSubtitle(title, description);
      symbolDescription.textContent = subtitle;
      
      downloadBtn.disabled = false;
      
      loading.classList.add('hidden');
    }, 1500);
  });
  
  randomBtn.addEventListener('click', function() {
    descriptionInput.value = getRandomDescription();
  });
  
  clearBtn.addEventListener('click', function() {
    descriptionInput.value = '';
    symbolWrapper.innerHTML = '';
    symbolTitle.textContent = 'Your AeonAnima Awaits';
    symbolDescription.textContent = 'Enter your description and generate your unique cosmic symbol.';
    downloadBtn.disabled = true;
  });
  
  downloadBtn.addEventListener('click', function() {
    if (!this.disabled) {
      downloadSVG();
    }
  });
  
  // Initialize with a random description
  descriptionInput.value = getRandomDescription();
});
</script>  
</body>
</html>